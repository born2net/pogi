For all the examples below 
```js
let pgdb:PgDb     = PgDb.connect(..);
let table:PgTable = pgdb.schemas['test1']['users'];  
```


## setLogger(logger:PgDbLogger) 
Note: inherited.

Sets the logger per table.

## async run(sql:string):Promise<Record[]>
Note: inherited, uses table level log if present (if not then schema, then db).

Executes an arbitrary sql string;
```js
await table.run('CREATE schema myschema');
```

## async query(sql:string, params?:any[]):Promise<Record[]>
## async query(sql:string, params?:Object):Promise<Record[]>
<a name="query"></a>
Note: inherited, uses table level log if present (if not then schema, then db).

Executes an arbitrary sql string with parameters / named parameters;
```js
let res1 = await table.query('SELECT MAX(point) from game1.scores WHERE name=$1 ', ['player1']);
let res2 = await table.query('SELECT MAX(point) from !:schema.scores WHERE name=:name ', {schema:'game1', name:'player1'});
```

## async getOneField(sql:string, params?:any[]):Promise<any>
## async getOneField(sql:string, params?:Object):Promise<any>
Note: inherited, uses table level log if present (if not then schema, then db).

If there is only one record and one field that we are interested in. For the params usage see [query](#query).
```js
let winner = await table.getOneField(`SELECT 'The winner is ' || name FROM ${table} LIMIT 1`);
console.log(winner); //The winner is Admin
```

## async getOneColumn(sql:string, params?:any[]):Promise<any[]>
## async getOneColumn(sql:string, params?:Object):Promise<any[]>
Note: inherited, uses table level log if present (if not then schema, then db).

If there is only one column that we are interested in. For the params usage see [query](#query).
```js
let userList = await table.getOneColumn(`SELECT name FROM ${table}`);
console.dir(userList); //['Admin', 'User1', 'User2']
```

## async insert(records:{}, returnResult?:boolean): Promise<Record>
## async insert(records:{}[], returnResult?:boolean): Promise<Record[]>
You can insert one or multiple records, by default the new record(s) will be returned. This can be prevented if not needed;
```js
let user = await table.insert({username:'anonymous'});
console.log(user.id); // generated by postgresql
```
## async updateOne(conditions:{[k:string]:any}, fields:{[k:string]:any}): Promise<number>
Run an update query, throws exception if more then one record has been updated. (Handy if you roll back on exception)
```js
await table.updateOne({id:1},{password:null});
await table.updateOne({notUniqId:1},{password:null}); //throws exception if more then 1 rec has been updated;
```
## async updateAndGetOne(conditions:{[k:string]:any}, fields:{[k:string]:any}): Promise<Record>
Run an update query and returns with the updated record, 
throws exception if more then one record has been updated. (Handy if you roll back on exception)
```js
let user = await table.updateOne({id:1},{password:null});
console.log(user.name); //the whole record is returned
```

## async update(conditions:{[k:string]:any}, fields:{[k:string]:any}):Promise<number>
Run an update query on the table
```js
await table.update({},{score:null}); //all record is updated
await table.update({'name ~': '^G'}, {numOfLifes:4}); //all record where name starts with G has the numOfLifes set to 4. It's a G'day!
```

## async updateAndGet(conditions:{[k:string]:any}, fields:{[k:string]:any}):Promise<number>
Run an update query on the table
```js
let playerList = await table.updateAndGet({'score >': '9000'}, {achivement:"It's Over 9000!"}); 
//update the achievement fields for all players where the score is over 9000 then returns the updated list
```

## async deleteAll():Promise<number>
Executes a "DELETE FROM schema.table" query (Note: not truncate).

```js
await table.deleteAll();
```

## async delete(conditions:{[k:string]:any}):Promise<number>
Executes a delete-where query.

```js
let numberOfRowsDeleted = await table.delete({id:[1,2,3]});
if (numberOfRowsDeleted!=3) {
    //alarm!!
}
```
# async deleteAndGet(conditions:{[k:string]:any}):Promise<Record[]>
Executes a delete-where query and returns with the deleted records;
```js
let playersDeleted = await table.deleteAndGet({id:[1,2,3]});
for (let player of playersDeleted) {
    console.log(player.id); //1 then 2 then 3
}
```
# async deleteOne(conditions:{[k:string]:any}):Promise<number>
Executes a delete-where query, but throws exception if more then one record is deleted;
```js
let numberOfDeleted = await table.deleteOne({id:[1,2,3]}); //throws exception if more then one record is deleted
console.log(numberOfDeleted); //0 or 1
```

# async deleteOneAndGet(conditions:{[k:string]:any}):Promise<Record[]>
Executes a delete-where query, but throws exception if more then one record is deleted;
Returns with the deleted record if any.
```js
let playerDeleted = await table.deleteAndGet({id:[1,2,3]});  //throws exception if more then one record is deleted
console.log(player.id); //Either 1, 2, 3 or null if no record is deleted

```
## async find(conditions:{[k:string]:any}, options?:QueryOptions):Promise<Record[]>
Executes a select-where query.
```js
let playerList = await table.find({id:[1,2,3]});
for (let player of playerList) {
    console.log(player.id); //1..2..3
}

playerList = await table.find({id:[1,2,3]}, {fields:['id', 'name'], limit:3});
```
for more options for conditions and queryOptions see those sections.

## async findWhere(where:string, params):Promise<Record[]>
Executes a select-where query with free text where etc. 
```js
let res;
res = await table.where("permissions @> {'admin'} AND name!=username AND id=$1  LIMIT 2", [1]);
res = await table.where("permissions @> {'admin'} AND name!=username AND id=:id LIMIT 2", {id:1});
```

## async findAll():Promise<Record[]>
Returns everything from the table. Same as table.find({})
```js
let res = await table.findAll();
```

## async findOne(conditions):Promise<Record>
Most system get this wrong, as they use it as "_findFirst_" instead of using as "_findOnly_". 
While 99% of the time the programmer means the latter, by default they use the formal.
That is mostly just hiding bugs instead of revealing issues as soon as possible. 
It's hard to count how much time it saved me to find an issue, not to mention that it found earlier 
then otherwise would find out. Very good investment for a small bit of _Defensive programming_.

Therefore it **throws exception** if more then one record match the select query.
```js
let res1 = await table.findOne({id:1});
let res2 = await table.findOne({'name like': 'A%'}); //most probably throws an exception
```

## async findFirst(conditions):Promise<Record>
Same as await table.find(condition, {limit:1})
```js
let somebody = await table.findFirst({'score >':9000});
```

## async count(conditions?):Promise<number>
Run a count query
```js
let count = await table.count({id:2});
console.log(count); //most probably 1
```

## async findOneFieldOnly(conditions, field:string):Promise<any>
Returns directly the value of a column/field directly.

```js
let nameOfUser = await table.findOneFieldOnly({id:1}, 'name');
console.log(nameOfUser); //most probably 'Admin'
```






